#!/bin/bash
# update-health-dashboard.sh
# Called by each agent on heartbeat to update their section in the health dashboard
#
# Usage: ./update-health-dashboard.sh "AgentName" "Creature"
# Example: ./update-health-dashboard.sh "Stilgar" "Bear"

set -e

# Configuration
AGENT_NAME="${1:-Unknown}"
AGENT_CREATURE="${2:-Unknown}"
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
DASHBOARD_PATH="${SCRIPT_DIR}/agent-health.md"
LOCK_DIR="/tmp/agent-health-dashboard.lock"
LOCK_TIMEOUT=10
UPTIME_DIR="/tmp"

# Validate args
if [ "$AGENT_NAME" = "Unknown" ] || [ "$AGENT_CREATURE" = "Unknown" ]; then
    echo "Usage: $0 <AgentName> <Creature>" >&2
    echo "Example: $0 Stilgar Bear" >&2
    exit 1
fi

# Get current timestamp (ISO 8601 format with timezone)
CURRENT_TIME=$(date +"%Y-%m-%dT%H:%M:%S %Z")

# Get current model and channel (with fallbacks)
# Prefer environment variables, fall back to openclaw CLI
if [ -n "$MODEL" ]; then
    CURRENT_MODEL="$MODEL"
elif command -v openclaw &> /dev/null; then
    # Get first line only and strip any whitespace
    CURRENT_MODEL=$(openclaw status --json 2>/dev/null | grep -o '"model"[[:space:]]*:[[:space:]]*"[^"]*"' | head -1 | cut -d'"' -f4 | tr -d '\n' || echo "unknown")
else
    CURRENT_MODEL="unknown"
fi

if [ -n "$CHANNEL" ]; then
    CURRENT_CHANNEL="$CHANNEL"
elif command -v openclaw &> /dev/null; then
    CURRENT_CHANNEL=$(openclaw status --json 2>/dev/null | grep -o '"channel"[[:space:]]*:[[:space:]]*"[^"]*"' | head -1 | cut -d'"' -f4 | tr -d '\n' || echo "telegram")
else
    CURRENT_CHANNEL="telegram"
fi

# Get config hash (first 8 chars of SHA-256)
if [ -n "$CONFIG_HASH" ]; then
    CURRENT_CONFIG_HASH="$CONFIG_HASH"
elif command -v openclaw &> /dev/null && openclaw gateway config.get --raw &> /dev/null; then
    CURRENT_CONFIG_HASH=$(openclaw gateway config.get --raw 2>/dev/null | shasum -a 256 | cut -d' ' -f1 | cut -c1-8)
else
    CURRENT_CONFIG_HASH="na"
fi

# Calculate uptime
UPTIME_FILE="${UPTIME_DIR}/${AGENT_NAME}-uptime-start"
CURRENT_EPOCH=$(date +%s)

if [ ! -f "$UPTIME_FILE" ]; then
    echo "$CURRENT_EPOCH" > "$UPTIME_FILE"
fi

START_TIME=$(cat "$UPTIME_FILE" 2>/dev/null || echo "$CURRENT_EPOCH")
UPTIME_SECONDS=$((CURRENT_EPOCH - START_TIME))
UPTIME_HOURS=$((UPTIME_SECONDS / 3600))
UPTIME_MINUTES=$(((UPTIME_SECONDS % 3600) / 60))
UPTIME_HUMAN="${UPTIME_HOURS}h ${UPTIME_MINUTES}m"

# Status will be determined by monitoring cron, default to Healthy for fresh updates
STATUS_EMOJI="ðŸŸ¢"
STATUS_TEXT="Healthy"

# Build the agent section
SECTION="## ${AGENT_NAME} (${AGENT_CREATURE})
- **Last Ping:** ${CURRENT_TIME}
- **Model:** ${CURRENT_MODEL}
- **Channel:** ${CURRENT_CHANNEL}
- **Status:** ${STATUS_EMOJI} ${STATUS_TEXT}
- **Config Hash:** ${CURRENT_CONFIG_HASH}
- **Uptime:** ${UPTIME_HUMAN}
"

# Function to acquire lock (mkdir is atomic on all Unix systems)
acquire_lock() {
    local waited=0
    while [ $waited -lt $LOCK_TIMEOUT ]; do
        if mkdir "$LOCK_DIR" 2>/dev/null; then
            # Write our PID for debugging
            echo $$ > "$LOCK_DIR/pid"
            return 0
        fi
        sleep 1
        ((waited++))
    done
    return 1
}

# Function to release lock
release_lock() {
    rm -rf "$LOCK_DIR" 2>/dev/null || true
}

# Function to update dashboard (with file locking)
update_dashboard() {
    # Acquire lock with timeout
    if ! acquire_lock; then
        echo "Warning: Could not acquire lock, skipping update" >&2
        return 0
    fi

    # Ensure lock is released on exit
    trap release_lock EXIT

    # Read current dashboard or create from template
    if [ -f "$DASHBOARD_PATH" ]; then
        DASHBOARD_CONTENT=$(cat "$DASHBOARD_PATH")
    else
        # Create from template
        DASHBOARD_CONTENT="# Agent Health Dashboard

**Last Updated:** ${CURRENT_TIME}
**Version:** 1

---

## ${AGENT_NAME} (${AGENT_CREATURE})
- **Last Ping:** ${CURRENT_TIME}
- **Model:** ${CURRENT_MODEL}
- **Channel:** ${CURRENT_CHANNEL}
- **Status:** ${STATUS_EMOJI} ${STATUS_TEXT}
- **Config Hash:** ${CURRENT_CONFIG_HASH}
- **Uptime:** ${UPTIME_HUMAN}

---

## Status Legend
- ðŸŸ¢ Healthy â€” Last ping < 30 min
- ðŸŸ¡ Warning â€” Last ping 30-60 min
- ðŸ”´ Critical â€” Last ping > 60 min
- âšª Unknown â€” No data

---

*Auto-generated by agent heartbeats. Do not edit manually.*
*Monitoring cron checks every 15 min.*"
        echo "$DASHBOARD_CONTENT" > "${DASHBOARD_PATH}.tmp"
        mv "${DASHBOARD_PATH}.tmp" "$DASHBOARD_PATH"
        release_lock
        return 0
    fi

    # Check if agent section exists
    if echo "$DASHBOARD_CONTENT" | grep -q "## ${AGENT_NAME} ("; then
        # Section exists, replace it
        # Write section to temp file to handle multiline
        SECTION_FILE="/tmp/agent-section-$$.tmp"
        echo "$SECTION" > "$SECTION_FILE"

        UPDATED_CONTENT=$(echo "$DASHBOARD_CONTENT" | awk -v section_file="$SECTION_FILE" -v agent="$AGENT_NAME" '
            BEGIN {
                section = ""
                while ((getline line < section_file) > 0) {
                    section = section line "\n"
                }
                close(section_file)
                sub(/\n$/, "", section)
                in_section = 0
            }
            # Match agent sections (have parens after name)
            /^## [A-Za-z]+ \(/ {
                if ($0 ~ "^## " agent " \\(") {
                    in_section = 1
                    print section
                    next
                }
                in_section = 0
            }
            /^---$/ { in_section = 0 }
            !in_section { print }
        ')

        rm -f "$SECTION_FILE"
    else
        # Section doesn't exist, add it after the first --- (after header)
        SECTION_FILE="/tmp/agent-section-$$.tmp"
        echo "$SECTION" > "$SECTION_FILE"

        UPDATED_CONTENT=$(echo "$DASHBOARD_CONTENT" | awk -v section_file="$SECTION_FILE" '
            BEGIN {
                section = ""
                while ((getline line < section_file) > 0) {
                    section = section line "\n"
                }
                close(section_file)
                sub(/\n$/, "", section)
                added = 0
            }
            /^---$/ && !added { print; print ""; print section; print ""; added = 1; next }
            { print }
        ')

        rm -f "$SECTION_FILE"
    fi

    # Update the Last Updated timestamp
    UPDATED_CONTENT=$(echo "$UPDATED_CONTENT" | sed "s/\*\*Last Updated:\*\* .*/\*\*Last Updated:\*\* ${CURRENT_TIME}/")

    # Atomic write: write to temp file, then move
    echo "$UPDATED_CONTENT" > "${DASHBOARD_PATH}.tmp"
    mv "${DASHBOARD_PATH}.tmp" "$DASHBOARD_PATH"

    release_lock
}

# Run the update
update_dashboard

echo "Health dashboard updated for ${AGENT_NAME}"
